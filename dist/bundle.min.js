import {parse}from'acorn';var g="do if in for let new try var case else enum null true void with await break catch class const false super throw while yield delete export import public return static switch typeof default extends finally package private continue debugger function arguments interface protected implements instanceof undefined NaN Math Number Object Array Set Map Date alert console decodeURI decodeURIComponent encodeURI encodeURIComponent JSON parseFloat parseInt prototype String setTimeout setInterval isPrototypeOf isNaN toString of Boolean RegExp Infinity isFinite Function Symbol Error BigInt Generator GeneratorFunction Promise async await AsyncFunction SyntaxError TypeError ReferenceError InternalError RangeError URIError".split(" ");
function l(a,b){b(a,c=>{{let b=a[c.parent];b?(c.functionScope=m.includes(b.type)?c.index:b.functionScope,c.blockScope=Math.max(n.includes(b.type)?b.index:b.blockScope,c.functionScope)):(c.functionScope=c.index,c.blockScope=c.index)}p(c);q(a,c)})}
function p(a){let b=[];a.hasOwnProperty("params")&&a.params.forEach(a=>{"Identifier"===a.type?b.push(a.name):"AssignmentPattern"===a.type?"Identifier"===a.left.type&&b.push(a.left.name):"ArrayPattern"===a.type?r(a,a=>{b.push(a)}):"ObjectPattern"===a.type&&t(a,a=>{b.push(a)})});a.hasOwnProperty("param")&&b.push(a.param.name);b.length&&(a.scopedParams=b)}
function r(a,b){a.elements.forEach(a=>{"Identifier"===a.type?b(a.name):"RestElement"===a.type&&"Identifier"===a.argument.type&&b(a.argument.name)})}function t(a,b){a.properties.forEach(a=>{"Identifier"===a.value.type&&b(a.value.name)})}
function q(a,b){switch(b.type){case "FunctionDeclaration":u(a[b.functionScope],"declaredIdentifiers",b.id.name);break;case "FunctionExpression":b.id&&u(a[b.functionScope],"declaredIdentifiers",b.id.name);break;case "ClassDeclaration":u(a[b.functionScope],"declaredIdentifiers",b.id.name);break;case "ImportDeclaration":b.specifiers.forEach(c=>{u(a[b.functionScope],"declaredIdentifiers",c.local.name)});case "VariableDeclaration":v(a,b)}}
function v(a,b){let c;"const"===b.kind||"let"===b.kind?c=a[b.blockScope]:"var"===b.kind&&(c=a[b.functionScope]);c&&b.declarations.forEach(a=>{"VariableDeclarator"===a.type&&("Identifier"===a.id.type?u(c,"declaredIdentifiers",a.id.name):"ArrayPattern"===a.id.type?r(a.id,a=>{u(c,"declaredIdentifiers",a)}):"ObjectPattern"===a.id.type&&t(a.id,a=>{u(c,"declaredIdentifiers",a)}))})}function u(a,b,c){a.hasOwnProperty(b)&&Array.isArray(a[b])?a[b].push(c):a[b]=[c]}
let m=["ClassDeclaration","FunctionDeclaration","FunctionExpression","ArrowFunctionExpression"],n="BlockStatement ForStatement ForInStatement ForOfStatement SwitchStatement CatchClause".split(" ");
function w(a,b,c,e,x){e=Array.isArray(e)?new Set(e):new Set;let k=[];b(a[0],(b,h)=>{if(void 0!==b.index){h=y(b,h);if("Identifier"===b.type){let d=!0,f=a[b.parent];d&&h.has(b.name)&&(d=!1);d&&c.has(b.name)&&(d=!1);d&&e.has(b.name)&&(d=!1);d&&f.key===b&&(d=!1);d&&f.property===b&&(d=!1);d&&f.imported===b&&(d=!1);d&&f.exported===b&&(d=!1);d&&f.label===b&&(d=!1);d&&(console.log(b.name),k.push(b))}"ThisExpression"===b.type&&!0!==x.allowThis&&k.push(b);return h}},void 0);return k}
function y(a,b){let c=new Set;b&&"[object Set]"===b.toString()&&b.forEach(a=>{c.add(a)});a.declaredIdentifiers&&a.declaredIdentifiers.forEach(a=>{c.add(a)});a.scopedParams&&a.scopedParams.forEach(a=>{c.add(a)});return c}function z(a,b){for(let c=0;c<a.length;c++)b(a[c])}
function A(a,b,c,e){(function f(a,b,c,d){let e=b?b(a,d):d;Object.values(a).forEach(d=>{"object"===typeof d&&null!==d&&(Array.isArray(d)?d.forEach(d=>{e=c?c(d,a,e):e;f(d,b,c,e)}):d.hasOwnProperty("type")&&(e=c?c(d,a,e):e,f(d,b,c,e)))})})(a,b,c,e)}
class B{constructor(){this.resetWhitelist()}check(a,b,c){"string"===typeof a&&this.getScopeTree(a,b);if(this.astArray)return a=w(this.astArray,A,this.whitelist,c,b),console.log(a),a}getScopeTree(a,b){"string"===typeof a&&this.parse(a,b);if(this.astArray)return l(this.astArray,z),this.ast}resetWhitelist(){this.whitelist=new Set(g)}removeFromWhitelist(a){if(Array.isArray(a))a.forEach(a=>{this.whitelist.delete(a)});else if("string"===typeof a)this.whitelist.delete(a);else throw Error("ReconJS: removeFromWhitelist only accepts a string or an array of strings as an argument");
}addToWhitelist(a){if(Array.isArray(a))a.forEach(a=>{this.whitelist.add(a)});else if("string"===typeof a)this.whitelist.add(a);else throw Error("ReconJS: addToWhitelist only accepts a string or an array of strings as an argument");}parse(a,b){this.ast=parse(a,b);this.buildASTArray(this.ast);return this.ast}buildASTArray(a){this.astArray=[a];a.index=0;a.parent=null;let b=1;A(a,void 0,(a,e)=>{a.hasOwnProperty("index")&&Object.entries(e).find(([b,c])=>{if(c===a)return a={...a},e[b]=a,!0});a.parent=e.index;
a.index=b;b++;if(1E5<b)throw Error("Too much code to parse");this.astArray.push(a)});console.log("astArray: ",this.astArray);for(a=0;a<this.astArray.length;a++)if(this.astArray[a].index!==a)throw Error("not matching");}}export default B;